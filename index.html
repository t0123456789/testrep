<!-- Learn about this code on MDN: https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Basic_2D_animation_example -->

<!doctype html>

<html lang="en">
<head>
    <title>Try out various things</title>
    <meta charset="utf-8">

    <style>
        body {
            margin: 0;
        }

        canvas {
            display: block;
            border: 2px solid black;
            background-color: black;
        }

        video {
            display: none;
        }
		
		.nav {
			background-color: pink; 
			list-style-type: none;
			text-align: center;
			margin: 0;
			padding: 0;
		}

		.nav li {
			display: inline-block;
			font-size: 20px;
			padding: 20px;
		}

    </style>

</head>

<body>

	<p>
	<a href="simple100.html">100% support (according to http://www.iwanttouse.com)</a>
	</p>
	
	<p>
	<a href="mpg/game.html">M P quiz</a>
	</p>
	
	<p>
	<a href="simple.html">Some 2d images and canvas</a>
	</p>
	
	<p>
	<a href="clear.html">Basic webGL cyan clear screen</a>
	</p>
	<p>
	<a href="quad.html">Basic webGL quad</a>
	</p>
	<p>
	<a href="spincube.html">Basic webGL spinning cube</a>
	</p>
	<p>
	<a href="unitypage.html">Unity webGL build</a>
	</p>
	
	<p>
	<a href="https://t0123456789.github.io/demo">Using Gatsby, React with Unity demo</a>
	</p>
	
	<p>
	Some useful links for testing browsers with features which may not be supported:
	</p>
	
	<ul>
	  <li><a href="https://webglreport.com/">WebGL version and features report which should display on all platforms.</a></li>
	  <li><a href="https://www.w3schools.com/css/css3_animations.asp">CSS3 example animation (reload while viewing green CSS icon)</a></li>
	  
	  <li><a href="https://www.testufo.com/animation-time-graph">Use requestAnimationFrame() API to vsync and test timing deviations.</a></li>	  
	  
	  <li><a href="https://webglfundamentals.org">WebGL 1 examples</a></li>
	  <li><a href="https://webglfundamentals.org/webgl/webgl-2d-rectangle-top-left.html">WebGL 1 example: hello world pink rectangle</a></li>
	  <li><a href="https://webgl2fundamentals.org/webgl/webgl-2d-rectangle-top-left.html">WebGL 2 example: hello world pink rectangle</a></li>
	  <li><a href="https://threejs.org/examples/?q=pano#webgl_panorama_equirectangular">Three.js example panorama image</a></li>

	  <li><a href="https://band-atom-camelotia.glitch.me">Glitch hello example</a></li>
	  <li><a href="https://statuesque-luck-ixora.glitch.me">Node express server on Glitch example</a></li>
	  <li><a href="https://illustrious-alpine-emoji.glitch.me">React app on Glitch example</a></li>
	  
	  <li><a href="https://codepen.io/gaearon/pen/gWWZgR?editors=0010">React example</a></li>
  
	</ul>
	
	<p>By default, list items are displayed vertically, use display: inline-block to display them horizontally.</p>
	<p>should also reposition automatically if you resize the browser window.</p>

	<ul class="nav">
	  <li><a href="#home">Home</a></li>
	  <li><a href="#about">About Us</a></li>
	  <li><a href="#clients">Our Clients</a></li>  
	  <li><a href="#contact">Contact Us</a></li>
	</ul>



    <canvas id="glcanvas" width="600" height="460">
        Oh no! Your browser doesn't support canvas!
    </canvas>


    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec2 aVertexPosition;

        uniform vec2 uScalingFactor;
        uniform vec2 uRotationVector;

        void main() {
        vec2 rotatedPosition = vec2(
        aVertexPosition.x * uRotationVector.y +
        aVertexPosition.y * uRotationVector.x,
        aVertexPosition.y * uRotationVector.y -
        aVertexPosition.x * uRotationVector.x
        );

        gl_Position = vec4(rotatedPosition * uScalingFactor, 0.0, 1.0);
        }
    </script>

    <script id="fragment-shader" type="x-shader/x-fragment">
        #ifdef GL_ES
        precision highp float;
        #endif

        uniform vec4 uGlobalColor;

        void main() {
        gl_FragColor = uGlobalColor;
        }
    </script>

    <script>

        let gl = null;
        let glCanvas = null;

        // Aspect ratio and coordinate system
        // details

        let aspectRatio;
        let currentRotation = [0, 1];
        let currentScale = [1.0, 1.0];

        // Vertex information

        let vertexArray;
        let vertexBuffer;
        let vertexNumComponents;
        let vertexCount;

        // Rendering data shared with the
        // scalers.

        let uScalingFactor;
        let uGlobalColor;
        let uRotationVector;
        let aVertexPosition;

        // Animation timing

        let previousTime = 0.0;
        let degreesPerSecond = 90.0;
        window.addEventListener("load", startup, false);

        function startup() {
            glCanvas = document.getElementById("glcanvas");
            gl = glCanvas.getContext("webgl");

            const shaderSet = [
                {
                    type: gl.VERTEX_SHADER,
                    id: "vertex-shader"
                },
                {
                    type: gl.FRAGMENT_SHADER,
                    id: "fragment-shader"
                }
            ];

            shaderProgram = buildShaderProgram(shaderSet);

            aspectRatio = glCanvas.width / glCanvas.height;
            currentRotation = [0, 1];
            currentScale = [1.0, aspectRatio];

            vertexArray = new Float32Array([
                -0.5, 0.5, 0.5, 0.5, 0.5, -0.5,
                -0.5, 0.5, 0.5, -0.5, -0.5, -0.5
            ]);

            vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertexArray, gl.STATIC_DRAW);

            vertexNumComponents = 2;
            vertexCount = vertexArray.length / vertexNumComponents;

            currentAngle = 0.0;
            rotationRate = 6;

            animateScene();
        }

        function buildShaderProgram(shaderInfo) {
            let program = gl.createProgram();

            shaderInfo.forEach(function (desc) {
                let shader = compileShader(desc.id, desc.type);

                if (shader) {
                    gl.attachShader(program, shader);
                }
            });

            gl.linkProgram(program)

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.log("Error linking shader program:");
                console.log(gl.getProgramInfoLog(program));
            }

            return program;
        }

        function compileShader(id, type) {
            let code = document.getElementById(id).firstChild.nodeValue;
            let shader = gl.createShader(type);

            gl.shaderSource(shader, code);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.log(`Error compiling ${type === gl.VERTEX_SHADER ? "vertex" : "fragment"} shader:`);
                console.log(gl.getShaderInfoLog(shader));
            }
            return shader;
        }

        function animateScene() {
            gl.viewport(0, 0, glCanvas.width, glCanvas.height);
            gl.clearColor(0.8, 0.9, 1.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            let radians = currentAngle * Math.PI / 180.0;
            currentRotation[0] = Math.sin(radians);
            currentRotation[1] = Math.cos(radians);

            gl.useProgram(shaderProgram);

            uScalingFactor =
                gl.getUniformLocation(shaderProgram, "uScalingFactor");
            uGlobalColor =
                gl.getUniformLocation(shaderProgram, "uGlobalColor");
            uRotationVector =
                gl.getUniformLocation(shaderProgram, "uRotationVector");

            gl.uniform2fv(uScalingFactor, currentScale);
            gl.uniform2fv(uRotationVector, currentRotation);
            gl.uniform4fv(uGlobalColor, [0.1, 0.7, 0.2, 1.0]);

            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);

            aVertexPosition =
                gl.getAttribLocation(shaderProgram, "aVertexPosition");

            gl.enableVertexAttribArray(aVertexPosition);
            gl.vertexAttribPointer(aVertexPosition, vertexNumComponents,
                gl.FLOAT, false, 0, 0);

            gl.drawArrays(gl.TRIANGLES, 0, vertexCount);

            window.requestAnimationFrame(function (currentTime) {
                let deltaAngle = ((currentTime - previousTime) / 1000.0)
                    * degreesPerSecond;

                currentAngle = (currentAngle + deltaAngle) % 360;

                previousTime = currentTime;
                animateScene();
            });
        }
    </script>

</body>

</html>
